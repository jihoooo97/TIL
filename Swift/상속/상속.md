# 상속

> 클래스는 어떤 메서드나 프로퍼티 등을 다른 클래스로부터 상속받을 수 있다.  
> 어떤 클래스로부터 상속을 받으면 상속받은 클래스는 그 어떤 클래스의 `자식클래스 - Subclass/Child-class`라고 표현한다.  
> 자식클래스에게 자신의 특성을 물려준 클래스를 `부모클래스 - Superclass/Parent-class`라고 표현한다.  
> 상속은 swift의 다른 타입과 클래스를 구별 짓는 클래스만의 특징이다.  

> Swift의 클래스는 부모클래스로부터 물려받은 메서드를 호출할 수 있고 프로퍼티에 접근할 수 있으며 서브스크립트도 사용할 수 있다. 또, 부모클래스로부터 물려받은 메서드, 프로퍼티, 서브스크립트 등을 자신만의 내용으로 재정의할 수 도 있다. Swift는 부모클래스의 요소를 자식클래스에서 재정의할 때 자식클래스가 부모클래스의 요소들을 재정의한다는 것을 명확히 확인해주어야 한다.  

> 상속받은 프로퍼티에 프로퍼티의 값이 변경되었을 때 알려주는 프로퍼티 감시자도 구현할 수 있다. 연산 프로퍼티를 정의해준 클래스에서는 연산 프로퍼티에 프로퍼티 감시자를 구현할 수 없지만, 부모클래스에서 연산 프로퍼티로 저장한 프로퍼티든 저장 프로퍼티로 정의한 프로퍼티든 자식클래스에서는 프로퍼티 감시자를 구현할 수 있다.

> 다른 클래스로부터 상속을 받지 않은 클래스를 `기반클래스 - Base Class`라고 한다. 어떤 클래스로부터 상속받지 않고 생성한 대부분의 클래스를 기반클래스로 생각해도 무방하다.

<br><br>


## 클래스 상속

> 상속은 기반클래스를 다른 클래스에서 물려받는 것을 말한다. 부모클래스의 메서드, 프로퍼티 등을 재정의하거나, 기반클래스의 기능이나 프로퍼티를 물려받고 자신의 기능을 추가할 수 있다.  
> 클래스 이름 뒤에 콜론을 붙이고 다른 클래스 이름을 써주면 뒤에 오는 클래스의 기능을 앞의 클래스가 상속받을 것임을 뜻한다.

```swift
class Person {
    var name: String = ""
    var age: Int = 0

    var introduction: String {
        return "이름: \(name), 나이: \(age)"
    }

    func speak() {
        print("안녕하세요?")
    }
}

class Student: Person {
    var grade: String = "F"
    
    func study() {
        print("Studying...")
    }
}

let jiho = Person()
jiho.name = "jiho"
jiho.age = 26
print(jiho.introduction) // 이름: jiho, 나이: 26
jiho.speak()             // 안녕하세요?

let naeun = Student()
naeun.name = "naeun"
naeun.age = 24
naeun.grade = "A"
print(naeun.introduction) // 이름: naeun, 나이: 24
naeun.speak()             // 안녕하세요?
naeun.study()             // Studying...
```

<br>

> Person 클래스를 상속받은 Student 클래스는 Person의 인스턴스 메서드, 타입 메서드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등 모튼 특성을 포함한다.  
> 다른 클래스를 상속받으면 똑같은 기능을 구현하기 위하여 코드를 다시 작성할 필요가 없으므로 코드를 재사용하기 용이하고 더불어 기능을 확장할 때 기존 클래스를 변경하지 않고도 새로운 추가 기능을 구현한 클래스를 정의할 수 있다.

<br><br>


## 재정의 - Override

> 자식클래스는 부모클래스로부터 물려받은 특성(인스턴스 메서드, 타입 메서드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등)을 그대로 사용하지 않고 자신만의 기능으로 변경하여 사용할 수 있다. 

> 상속받은 특성들을 재정의하려면 새로운 정의 앞에 override라는 키워드를 사용한다.  
override 키워드는 스위프트 컴파일러가 조상클래스(부모를 포함한 그 상위 부모클래스)에 해당 특성이 있는지 확인한 후 재정의하게 된다. 만약 조상클래스에 재정의할 해당 특성이 없는데 override 키워드를 사용하면 컴파일 오류가 발생한다.

> 만약 자식클래스에서 부모클래스의 특성을 재정의했을 때, 부모클래스의 특성을 자식클래스에서 사용하고 싶다면 super 프로퍼티를 사용하면 된다. 즉, 자식클래스에서 특성을 재정의했지만 필요에 따라 부모클래스의 특성을 활용하고 싶을 때 super를 사용한다. super키워드를 타입 메서드 내에서 사용한다면, 부모클래스의 타입 메서드와 타입 프로퍼티에 접근할 수 있으며 인스턴스 메서드 내에서 사용한다면, 부모클래스의 인스턴스 메서드와 인스턴스 프로퍼티, 서브스크립트에 접근할 수 있다.

<br>


### 메서드 재정의

> 부모클래스로부터 상속받은 인스턴스 메서드나 타입 메서드를 자식클래스에서 용도에 맞도록 재정의할 수 있다.

```swift
class Person {
    var name: String = ""
    var age: Int = 0

    var introduction: String {
        return "이름: \(name), 나이: \(age)"
    }

    func speak() {
        print("말말말")
    }

    class func introduceClass() -> String {
        return "접니다"
    }
}

class Student: Person {
    var grade: String = "F"

    func study() {
        print("열공")
    }

    override func speak() {
        print("안녕하세요?")
    }
}

class UnivercityStudent: Student {
    var major: String = ""

    class func introduceClass() {
        print(super.introduceClass())
    }

    override func introduceClass() -> String {
        return "제 소원은 여자친구 입니다."
    }

    override func speak() {
        super.speak()
        print("대학생입니다.")
    }
}

let jiho = Person()
jiho.speak()   // 말말말

let naeun = Student()
naeun.speak()  // 안녕하세요?

let miyeon = UnivercityStudent()
miyeon.speak() // 안녕하세요? 대학생입니다.

print(Person.introduceClass())               // 접니다
print(Student.introduceClass())              // 접니다
UnivercityStudent.introduceClass() as String // 제 소원은 여자친구 입니다.
UnivercityStudent.introduceClass() as Void   // 접니다
```

<br>

> Student 클래스는 Person 클래스를 상속받았고, UnivercityStudent 클래스는 Student 클래스를 상속받았다.  
> Student 클래스에서 Person 클래스에 정의된 speak() 메서드를 재정의했고, UnivercityStudent 클래스에서는 Person 클래스의 introduceClass() 메서드를 재정의했다.  
> Student 클래스에서 재정의한 speak() 메서드는 UnivercityStudent 클래스로 상속되었으므로 UnivercityStudent 클래스의 인스턴스는 speak() 메서드를 호출하면 Student 클래스에서 재정의한 메서드가 호출된다.  

> UnivercityStudent 클래스의 introduceClass() 메서드에 override 키워드가 붙은 메서드와 그렇지 않은 메서드 두 가지가 있는 이유는 바로 반환 타입이 다르기 때문이다. Swift는 메서드의 반환 타입이나 매개변수가 다르면 서로 다른 메서드로 취급한다.  

> 또, 부모 클래스의 메서드에 접근하기 위해서는 UnivercityStudent 클래스의 speak()와 introduceClass() 메서드에서처럼 super 프로퍼티를 사용하면 된다.