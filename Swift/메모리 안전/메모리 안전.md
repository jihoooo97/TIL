 # 메모리 안전

<br>

## 메모리 접근 충돌의 이해

> 프로그래머가 변수에 값을 할당한다던가 함수의 전달인자로 변수의 값을 전달하는 등 다양한 경우에 코드를 통해 메모리에 접근하게 된다.

```swift
// one이 저장될 메모리 위치에 쓰기 접근
var one: Int = 1

// one이 저장된 메모리 위치에 읽기 접근
print("숫자 출력: \(one)")
```

<br>

> 메모리 접근 충돌은 서로 다른 코드에서 동시에 같은 위치의 메모리에 접근할 때 발생한다. 동시에 여러 접근을 하게 되면 예상치 못한 결과를 얻을 수 있다. 예를 들어, 어떤 인스턴스의 내부의 여러 프로퍼티의 값을 합산하여 반환하는 함수가 있을 때, 외부의 한 코드에서 인스턴스의 프로퍼티 값 일부를 수정하고, 동시에 또 다른 어딘가의 코드에서 합산하여 결과를 돌려주는 함수를 호출한다면 그 결과를 예측할 수 있을까? 동시에 일어나는 일이라면 수정 전의 합산 결과를 돌려줄지, 수정된 값의 합산 결과를 돌려줄지 누구도 장담할 수 없다. 이런 일이 발생하지 않을 것이라고 생각하겠지만, 다중 스레드 프로그램에서는 흔히 겪을 수 있는 일이다.

<br>


### 메모리 접근의 특성

> 메모리 접근 충돌을 일으키는 메모리 접근에는 세 가지 특성이 있다. 다음의 세 가지 조건에 모두 해당하는 메모리 접근이 두 군데 이상의 코드에서 동시에 일어나면 메모리 접근 충돌이 발생한다.
> - 최소한 한 곳에서 쓰기 접근한다
> - 같은 메모리 위치에 접근한다
> - 접근 타이밍이 겹친다
>
> 순차적으로 코드를 실행하고, 메모리에 접근하는 것이 순간적이라면 다른 코드에서 같은 메모리 위치에 동시에 접근할 일이 없다. 단일 스레드 환경에서는 대부분의 메모리 접근이 순간적 접근이고 동시에 다른 코드에서 접근할 일이 없다.

```swift
func oneMore(than number: Int) -> Int {
    return number + 1
}

var myNumber: Int = 1
myNumber = oneMore(than: myNumber)
print(myNumber) // 2
```

<br>

> 반면에 장기적 메모리 접근이라는 접근 방식도 있다. 장기적 메모리접근 중에는 해당 메모리 접근이 끝나기 전에 다른 코드에서 메모리에 접근할 가능성이 있다. 접근 타이밍이 겹치게 되는 것이다.

> 접근 타이밍이 겹치게되는 대표적 상황은 함수나 메서드에서 inout을 사용한 입출력 매개변수를 사용하는 경우나 구조체에서 mutating 키워드를 사용하는 가변 메서드를 사용하는 경우이다. 메모리의 같은 위치에 접근하는 여러 접근의 타이밍이 겹친다고해서 무조건적으로 메모리 접근 충돌이 발생하는 것은 아니다. 그렇지만 접근 타이밍이 겹치는 경우 대개 메모리 접근 충돌이 발생할 가능성이 크다. 메모리 접근 충돌을 코드에서 정적으로 예측할 수 있는 경우 컴파일러에서 오류로 취급하여 컴파일하지 않는다.

<br><br>


### 입출력 매개변수에서의 메모리 접근 충돌

> 입출력 매개변수를 갖는 함수는 동작 중 모두 장기적 메모리 접근을 한다. 즉, 함수의 실행과 동시에 입출력 매개변수의 쓰기 접근이 시작되고 함수가 종료될 때까지 쓰기 접근을 유지한다. 함수가 종료될 때 쓰기 접근을 종료한다.

> 입출력 매개변수를 통한 장기적 메모리 접근 중에는 매개변수로 전달하는 변수는 다른 접근이 제한된다.

```swift
var step: Int = 1

func increment(_ number: inout Int) {
    number += 1
}

increment(&step)
```

<br>

> `step` 변수는 `increment(_:)` 함수의 입출력 매개변수로 전달되었는데 함수 내부에서 같은 메모리 공간에 읽기 접근을 하려고 시도하기 때문에 메모리 접근 충돌이 발생한다. 그래서 런타임 오류가 발생한다. 이런 경우 새로운 변수를 생성해서 해결할 수 있다.

```swift
var step: Int = 1
var copyOfStep: Int = step

func increment(_ number: inout Int) {
    number += copyOfStep
}

increment(&step)
```

<br>

> 입출력 매개변수에서 메모리 접근 충돌이 발생할 수 있는 다른 예를 들자면 두 개 이상의 입출력 매개변수로 같은 변수를 전달하는 상황을 들 수 있다.

```swift
func balance(_ x: inout Int, _ y: inout Int) {
    let sum = x + y
    x = sum / 2
    y = sum - x
}

var playerOneScore: Int = 42
var playerTwoScore: Int = 30

balance(&playerOneScore, &playerTwoScore)
balance(&playerOneScore, &playerOneScore)  // [Error]
```

<br>

> 첫 번째 함수 호출의 경우 각각 다른 변수를 입출력 매개변수로 전달하여 문제가 없지만, 두 번째 호출의 경우 같은 변수를 동시에 두 개의 입출력 매개변수로 전달하여 메모리 접근 충돌이 발생한다. 왜냐하면 playerOneScore라는 변수의 메모리 위치를 함수가 실행되는 동안 동시에 장기적 접근을 시도하기 때문에 문제가 발생한다. 이 경우에는 컴파일러에서 미리 컴파일 오류로 알려준다.

<br><br>

### 메서드 내부에서 self 접근의 충돌

> 구조체의 가변 메서드는 메서드 실행 중에 `self`에 쓰기 접근을 한다. 게임 캐릭터를 구조체로 구현했다고 생각했을 때, 캐릭터가 상처를 입으면 체력이 닳는다. 체력을 다시 회복하는 메서드와 체력을 다른 캐릭터와 공유하는 메서드를 만들고 그것을 아래와 같이 표현해 보았다.

```swift
struct GamePlayer {
    var name: String
    var health: Int
    var energy: Int

    static let maxHealth = 10

    mutating func restoreHealth() {
        self.health = GamePlayer.maxHealth
    }

    mutating func shrareHealth(with teammate: inout GamePlayer) {
        balance(&teammate.health, &health)
    }
}
```

<br>

> `restoreHealth()` 메서드는 실행 중 인스턴스 자신인 `self`에 장기적으로 쓰기 접근을 한다. 
> 현재 `restoreHealth()` 메서드는 내부의 코드 중 인스턴스의 다른 프로퍼티를 동시에 접근하는 코드가 없다. 
> 반면에 `shareHealth(with:)` 메서드는 다른 캐릭터의 인스턴스를 입출력 매개변수로 받기 때문에 메모리 접근 충돌이 발생할 여지가 있다.

```swift
// 메모리 접근 충돌이 없는 shareHealth(with:) 메서드 호출
var jiho = GamePlayer(name: "Jiho", health: 10, energy: 10)
var chaewon = GamePlayer(name: "Chaewon", health: 5, energy: 10)

jiho.shareHealth(with: &chaewon)
```

<br>

> 위에서 `shareHealth(with:)` 메서드 호출은 메모리 접근 충돌을 일으키지 않는다.
> teammate 입출력 매개변수로 전달된 chaewon은 `shareHealth(with:)` 메서드가 실행되는 중에 쓰기 접근을 하고, 가변 메서드를 실행해야 하는 jiho도 쓰기 접근을 한다. 
> 하지만 서로 다른 메모리 위치에 있기 때문에 메모리 접근 충돌이 발생하지 않는 것이다.

```swift
// 메모리 접근 충돌이 발생하는 shareHealth(with:) 메서드 호출
jiho.shareHealth(with: &jiho) // [Error]
```

<br>

> teammate 입출력 매개변수로 전달받은 메모리 위치와 jiho 인스턴스의 메모리 위치는 같은 곳이기 때문에 동시에 쓰기 접근을 하면 메모리 충돌이 발생한다.

<br><br>
