# 모나드

> 모나드라는 용어는 수학의 범주론에서부터 시작한다.  
> 함수형 프로그래밍에서의 모나드는 순서가 있는 연산을 처리할 때 자주 활용하는 디자인 패턴이기도 하다. 
> 프로그래밍에서 사용하는 모나드는 범주론의 모나드의 의미를 완벽히 구현하려고 하지 않기 때문에 범주론의 모나드 개념을 차용한 정도의 의미를 갖는다. 
> 그래서 모나드의 성질을 완벽히 갖추지 못했지만 대부분의 성질을 갖추었다고 하여 프로그래밍에서의 모나드를 `모나딕 - Monadic`이라고 표현한다. 혹은 모나드의 성질을 갖는 타입이나 함수를 `모나딕 타입` 혹은 `모나딕 함수` 등으로 표현하기도 한다  

<br>

### 모나드가 갖춰야 하는 조건
- 타입을 인자로 받는 타입(특정 타입의 값을 포장)
- 특정 타입의 값을 포장한 것을 반환하는 함수(메서드)가 존재
- 포장된 값을 변환하여 같은 형태로 포장하는 함수(메서드)가 존재

<br>

> 모나드를 이해하는 출발점은 값을 어딘가에 포장하는 개념을 이해하는 것에서 출발한다.  
> swift에서 모나드를 사용한 예 중 하나가 바로 옵셔널이다. 옵셔널은 값이 있을지 없을지 모르는 상태를 포장하는 것이다.  
> `함수객체 - Functor`와 모나드는 특정 기능이 아닌 디자인 패턴 혹은 자료구조라고 할 수 있다.

<br>


## 컨텍스트

> 사전적 정의로 `맥락`, `전후 사정` 등이다.  
> 컨텍스트는 `콘텐츠를 담은 그 무엇인가`를 뜻한다. (ex: 물컵에 물이 담겨있으면 물은 콘텐츠, 물컵은 컨텍스트)  
> 2라는 숫자를 옵셔널로 둘러싸면, `컨텍스트는 2라는 값을 가지고 있다`고 말할 수 있다.  
> 만약 값이 없는 옵셔널 상태라면 `컨텍스트는 존재하지만 내부에 값이 없다`고 말할 수 있다.  
> Optional은 Wrapped 타입을 인자로 받는 제네릭 타입이다. 즉, 모나드의 첫 번째 조건을 만족하는 타입이다.  
> 그리고 Optional 타입은 Optional<Int>.init(2) 처럼 다른 타입의 값을 갖는 상태의 컨텍스트를 생성할 수 있으므로 모나드의 두 번째 조건을 만족한다.  

<br>

```swift
func addThree(_ num: Int) -> Int {
    return num + 3
}
```
<br>

> addThree 함수는 매개변수로 일반 Int 타입의 값을 받기 때문에 전달인자로 컨텍스트에 들어있지 않은 순수 값인 2를 전달하면 정상적으로 함수를 실행할 수 있다.  
> 하지만 옵셔널을 전달인자로 사용하려고 한다면 오류가 발생한다. 순수한 값이 아닌 옵셔널이라는 컨텍스트로 둘러싸여 전달되었기 때문이다.

<br><br>


## 함수객체

> map은 컨테이너(컨테이너는 다른 타입의 값을 담을 수 있으므로 컨텍스트의 역할을 수행할 수 있다)의 값을 변형시킬 수 있는 고차함수다. 그리고 옵셔널은 컨테이너와 값을 갖기 때문에 map 함수를 
사용할 수 있다.

<br>

```swift
Optional(2).map(addThree)  // Optional(5)

var value: Int? = 2
value.map { $0 + 3 }  // Optional(5)
value = nil
value.map { $0 + 3 }  // nil (== Optional<Int>.none)
```
> map을 예시로 든 이유는 `함수객체`란 map을 적용할 수 있는 컨테이너 타입이라고 말할 수 있기 때문이다.  

<br>

> 함수객체에서 map의 동작 과정  
> 옵셔널의 map(_:) 메서드를 호출하면 옵셔널 스스로 switch 구문으로 값이 있는지 없는지 판단한다.  
> 값이 있다면 전달받은 함수 f에 자신의 값을 적용한 결괏값을 다시 컨텍스트에 넣어 반환하고  
> 그렇지 않다면 함수를 실행하지 않고 빈 컨텍스트를 반환한다.
```swift
extension Optional {
    func map<U>(f: (Wrapped) -> U) -> U? {
        switch self{
            case .some(let x): return f(x)
            case .none: return .none
        }
    }
}
```
<br><br>


## 모나드

> 함수객체 중에서 자신의 컨텍스트와 같은 컨텍스트의 형태로 맵핑할 수 있는 함수객체를 `닫힌 함수객체 - Endofunctor`라고 한다. 모나드는 닫힌 함수객체이다.  
> 함수객체는 포장된 값에 함수를 적용할 수 있었다. 그래서 모나드도 컨텍스트에 포장된 값을 처리하여 포장된 값을 컨텍스트에서 다시 반환하는 함수(map)를 적용할 수 있었다.  
> 이 매핑의 결과가 함수객체와 같은 컨텍스트를 반환하는 함수객체를 모나드라고 할 수 있으며, 이런 맵핑을 수행하도록 `플랫맵 - flatMap`이라는 메서드를 활용한다.  
> flatMap은 map과 같이 함수를 매개변수로 받고, 옵셔널은 모나드이므로 flatMap을 사용할 수 있다.

```swift
func doubleEven(_ num: Int) -> Int? {
    if num.isMultiple(of: 2) {
        return num * 2
    }
    return nil
}

Optional(3).flatMap(doubleEven)  // nil (== Optional<Int>.none)
```
<br>

> 만약 Optional.none.flatMap(doubleEven)과 같이 빈 컨텍스트에서 flatMap을 사용하는 경우 map과 flatMap의 차이가 없어 잘못 사용하는 경우가 있다.  
> 하지만 flatMap은 컨텍스트 내부의 컨텍스를 모두 같은 위상으로 평평하게 펼쳐준다는 차이가 있다.
> Sequence 타입이 Optional 타입의 Element를 포장한 경우에는 compactMap(_:)이라는 이름을 사용한다.

```swift
let optionals: [Int?] = [1, 2, nil, 5]

let mapped: [Int?] = optionals.map { $0 }
let compactMapped: [Int] = optionals.compactMap { $0 }

print(mapped)         // [Optional(1), Optional(2), nil, Optional(5)]
print(compactMapped)  // [1, 2, 5]
```

> 